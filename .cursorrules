# AI Instructions & Project Rules

This file is the single source of truth for coding rules.
Both **Claude Code** and **Cursor** read it (`CLAUDE.md` is a symlink to this file).

---

## Commands (Claude Code)

| Task | Command |
|------|---------|
| Dev server | `npm run dev` |
| Build | `npm run build` |
| Typecheck | `npm run typecheck` |
| Lint + fix | `npm run lint:fix` |
| Lint Markdown | `npm run lint:md` |
| Lint .env files | `npm run lint:env` |
| Lint shell scripts | `npm run lint:shell` |
| All unit tests | `npm run test` |
| Single test file | `npx vitest run path/to/file.test.ts` |
| Watch tests | `npm run test:unit:watch` |
| Coverage (80% threshold) | `npm run test:coverage` |
| E2E tests | `npm run test:e2e` |
| DB push migrations | `npm run db:push` |
| DB seed | `npm run db:seed` |
| DB studio (GUI) | `npm run db:studio` |
| Storybook | `npm run storybook` |
| Perf check | `npm run perf:check` |
| Lighthouse only | `npm run perf:lighthouse` |

> **Last step of any global change:** run `npm run lint:fix` to satisfy Biome import ordering.

---

## 1. Project Snapshot

**Stack:** Next.js 16 (App Router, React Compiler enabled), React 19, TypeScript strict, Tailwind CSS v4, Shadcn/UI, Drizzle ORM + libsql, Zod, t3-oss/env-nextjs, Biome, Vitest + React Testing Library, Playwright, Lighthouse, Storybook, Node.js v24.

**Architecture: Feature-Sliced Design (FSD)**

```
src/
├── app/              # Next.js routing and pages
│   └── lib/data-loaders/  # Route-specific data fetchers
├── shared/           # Reusable low-level code
│   ├── api/db/       # Drizzle schema, base repository, custom types
│   ├── config/       # Site config, env validation (t3-oss/env), security policies
│   ├── lib/          # Utilities (cn, validation, security, schema utils)
│   ├── model/        # Cross-entity Zod schemas (Contact, Category…)
│   ├── testing/      # Test factories and helpers
│   └── ui/           # Shared UI components
├── entities/         # Domain models: business, location, service, user, contact
├── widgets/          # Compositional blocks (business-list, directory-layout)
└── views/            # Page compositions
```

**Routes:** `[country]/[city]/page.tsx`, `[country]/[city]/[service]/page.tsx`, `service/[service]/page.tsx`.
**Route Groups:** `(listing)`, `(dashboard)`, `(blog)`, `(admin)`.
**Deployment:** `NEXT_OUTPUT_MODE=serverless|static|standalone` (see `.env.example`).

---

## 2. Safety Rules

### ⚠️ Dual-Barrel Rule (FSD Public APIs)

Every entity exposes **two entry points only**. Never import from internal paths.

| Entry point | Used by | Contains |
|-------------|---------|----------|
| `@/entities/xxx` (`index.ts`) | Client components, widgets, views | UI, selectors, validation — no DB/Node.js imports |
| `@/entities/xxx/server` (`server.ts`) | Data loaders, Server Components | React-cached accessors backed by the repository |

```ts
// ✅ Correct
import { BusinessCard } from "@/entities/business";
import { filterBusinesses } from "@/entities/business/server";

// ❌ Violates FSD — leaks DB code into client bundles and breaks Storybook
import { filterBusinesses } from "@/entities/business/api/accessors";
import { BusinessSchema } from "@/entities/business/model/schema";
```

### Critical Checklist

Before generating or modifying code, verify:

1. **TDD** — write failing test → minimal pass → refactor green
2. **FSD Public APIs** — import via `index.ts` (browser-safe) or `server.ts` (server-only) — never deep paths like `@/entities/xxx/api/accessors`
3. **DRY** — refactor repeated logic; extract shared patterns
4. **Type Reuse** — export types from Zod schemas; no duplicate type definitions
5. **Single Responsibility** — each module/factory does one thing
6. **Schema Compliance** — mock/seed data uses valid UUIDs and validates against schemas

---

## 3. Coding Standards

**Strict functional programming — no classes.** Use factory functions, composition, and closures.

- **Named exports for components:** `export function BusinessCard() { ... }` (better stack traces, automatic displayName)
- **Arrow functions for logic:** `const logicName = () => { ... }` for utilities, hooks, event handlers
- **No default exports** except Next.js files (`page.tsx`, `layout.tsx`)
- **No `useMemo`/`useCallback`/`React.memo`** — React Compiler handles this
- **No `forwardRef`** — use React 19's `ref` prop
- **Server Components by default** — `'use client'` only when hooks/DOM events needed

### Factory Pattern

```typescript
type CounterService = {
  increment: () => void;
  getCount: () => number;
};

const createCounterService = (initialValue = 0): CounterService => {
  let count = initialValue; // Private state via closure
  return {
    increment: () => { count += 1; },
    getCount: () => count,
  };
};
```

- **`create...`** — returns an interface the caller controls: `createService() → { start, stop }`
- **`start...`** — fire-and-forget background process: `startHealthServer()`
- Always define explicit return types as the "contract"

### Dependency Injection (DIP)

```typescript
// ❌ Internal coupling — never instantiate inside a factory
const createUserService = () => {
  const db = createDatabase();
};

// ✅ Inject dependencies as arguments
const createUserService = (db: Database) => { ... };
```

### Naming

| Scope | Convention |
|-------|-----------|
| Files | `kebab-case` |
| Functions, variables | `camelCase` |
| Types, schemas, components | `PascalCase` |
| Compile-time constants | `SCREAMING_SNAKE_CASE` |

### Imports

- **Absolute `@/`** for cross-boundary imports
- **Relative** only for same-directory siblings
- Never import entity internals — use `index.ts` (browser-safe) or `server.ts` (server-only)

```ts
// ✅
import { cn } from "@/shared/lib/utils"
import { BusinessCard } from "@/entities/business"
import type { Business } from "./schema"   // same-directory sibling

// ❌
import { Business } from "@/entities/business/model/schema"
```

### Other

- **Naming over comments** — expressive names, extract magic values to named constants; avoid numbered comments
- **Semantic HTML** — `<header>`, `<main>`, `<footer>` hierarchy
- **Typography** — `text-balance` for h1–h3, `text-pretty` for body text
- **State** — prefer `searchParams` over global client state; Server Actions for mutations
- **Metadata** — never hardcode in `layout.tsx`/`page.tsx` — pull from `@/shared/config`
- **Commits** — atomic, focused on single feature/fix

---

## 4. Entity Pattern

Each entity (e.g., `src/entities/business/`) follows:

```
model/schema.ts      # Zod schemas — single source of truth for types
model/types.ts       # TypeScript types extracted from schemas
model/selectors.ts   # Drizzle query builders
model/mapper.ts      # Domain mapper: (raw: XxxRaw, joins: XxxJoins) => Xxx, calls XxxSchema.parse()
model/validation.ts  # Validation logic
api/*-repository.ts  # Repository factory (CRUD + custom methods)
api/accessors.ts     # React-cached accessor functions (server-only)
ui/                  # React components
index.ts             # Browser-safe public API (UI, selectors, validation — no DB/Node.js)
server.ts            # Server-only public API (re-exports from api/accessors.ts)
```

### Repository Pattern

Base factories in `src/shared/api/db/base-repository.ts`:

- `createRepository(db, table, parse?)` — basic CRUD; pass `(r) => XxxSchema.parse(r)` to validate at the DB boundary
- `createSlugRepository(db, table, parse?)` — adds `getBySlug()`

Entity repositories extend these with domain-specific methods (e.g., `createBusinessRepository(db)` adds `filters()`, `getPopularPaths()`).

### Data Loaders

`src/app/lib/data-loaders/` — route-specific loaders using `loadDirectoryPageData(entityFetcher, criteriaBuilder)`.

---

## 5. Testing Strategy

### Two-Tier Factories (`src/shared/testing/factories/`)

- **`createRaw()`** — flat DB-compatible objects for repository/integration tests
- **`create()`** — rich nested objects validated against Zod schemas, for component/page tests

`vitest.setup.ts` runs DB migrations and clears all tables between tests.

### Rules

- **TDD** — failing test first, minimal code to pass, refactor green
- **Decouple tests** — explicit test data, not shared config imports
- **`beforeEach` variables** — use definite assignment assertion `!`:

```ts
// ✅ Correct — TypeScript knows it's always set before the first it()
let service!: ReturnType<typeof createServiceRaw>;

// ❌ Wrong — widens type and hides missing initialiser
let service: ReturnType<typeof createServiceRaw>;
```

Use `?.` only on genuine optionals (e.g., query results that can return `undefined`), never on `beforeEach`-assigned variables.
